/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { useGLTF, useScroll } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import React, { useRef, useEffect } from "react";
import * as THREE from "three";
import { usePlay } from "../contexts/Play";

const HELIX_SPEED = 6;

export function Airplane(props) {
  const { nodes, materials } = useGLTF("/models/airplane/Star.glb");
  const scroll = useScroll();
  const { hasScroll } = usePlay();
  
  const star1 = useRef();
  // const star2 = useRef();
  // const star3 = useRef();

  // New: target positions for smooth floating
  const targets = [useRef()];
  const bounds = 1; // Reduced bounds for more controlled movement
  const lerpSpeed = 0.03; // Reduced for smoother movement
  const rotationSpeed = 0.5; // Slower rotation for more elegance

  // Spiral parameters
  const spiralSpeed = 1;
  const spiralRadius = 0.8;
  const verticalSpeed = 0.1;
  const phaseOffset = (2 * Math.PI) / 3; // 120 degrees between each star
  const horizontalOffset = 0.5; // Offset for horizontal movement
  const verticalRange = 0.1; // Reduced vertical range

  // Rest positions for the stars (diagonal formation)
  const restPositions = [
    new THREE.Vector3(-0.9, -0.8, 0), // bottom left, moved right
    new THREE.Vector3(0.3, 0, 0),     // center, moved right
    new THREE.Vector3(0.8, 0.8, 0),   // top right
  ];

  // Trail history for each star
  const trailLength = 12; // Reduced trail length for tighter trails
  const trails = [useRef([])];

  // Helper to get spiral position
  function getSpiralPosition(time, phase) {
    const angle = time * spiralSpeed + phase;
    const radius = spiralRadius;
    
    // Create horizontal spiral by using z instead of y for the vertical component
    const x = Math.cos(angle) * radius;
    const z = Math.sin(angle) * radius;
    const y = (time * verticalSpeed) % verticalRange - (verticalRange / 2); // Reduced vertical oscillation
    
    // Add horizontal offset to create a more dynamic pattern
    return new THREE.Vector3(
      x + Math.sin(time * 0.5) * horizontalOffset,
      y,
      z + Math.cos(time * 0.5) * horizontalOffset
    );
  }

  // Initialize targets on mount
  useEffect(() => {
    targets.forEach((target, i) => {
      target.current = getSpiralPosition(0, i * phaseOffset);
    });
  }, []);

  useFrame((_state, delta) => {
    // const stars = [star1, star2, star3];
    const stars =[star1];
    if (!hasScroll) {
      // Set stars to rest positions
      stars.forEach((star, i) => {
        if (star.current) {
          star.current.position.lerp(restPositions[i], 0.2);
          // Reset trail to rest position
          trails[i].current = Array(trailLength).fill(restPositions[i].clone());
        }
      });
      return;
    }

    // Animate stars when scrolling
    const time = _state.clock.getElapsedTime();
    stars.forEach((star, i) => {
      if (!star.current) return;
      
      // Calculate new target position in spiral
      const targetPos = getSpiralPosition(time, i * phaseOffset);
      const currentPos = star.current.position;
      const distance = currentPos.distanceTo(targetPos);
      
      // Dynamic lerp speed based on distance
      const dynamicLerpSpeed = Math.min(lerpSpeed * (distance * 2), lerpSpeed);
      star.current.position.lerp(targetPos, dynamicLerpSpeed);
      
      // Add some tilt to the stars as they spiral
      star.current.rotation.x = Math.sin(time + i * phaseOffset) * 0.5;
      star.current.rotation.z = Math.cos(time + i * phaseOffset) * 0.5;
      star.current.rotation.y += delta * rotationSpeed;
      
      // // Update trail with smoother transitions
      // const pos = star.current.position.clone();
      // if (!trails[i].current.length) {
      //   trails[i].current = Array(trailLength).fill(pos);
      // } else {
      //   trails[i].current.push(pos);
      //   if (trails[i].current.length > trailLength) {
      //     trails[i].current.shift();
      //   }
      // }
    });
  });

  return (
    <group {...props} dispose={null}>
      {/* Star 1 - Top Vertex of Triangle */}
      <mesh
        ref={star1}
        geometry={nodes.pCylinder3001.geometry}
        material={materials['blinn2SG.001']}
        position={restPositions[0].toArray()}
        scale={[0.004, 0.004, 0.004]}
        rotation={[0, 0, 0]}
      >
        <meshStandardMaterial 
          color="white"
          metalness={0.5}
          roughness={0.2}
          emissive="white"
          emissiveIntensity={0.5}
        />
      </mesh>
      {/* Trail for Star 1 */}
      {/* <line>
        <bufferGeometry attach="geometry">
          <bufferAttribute
            attach="attributes-position"
            count={trails[0].current.length}
            array={new Float32Array(trails[0].current.flatMap(v => v.toArray()))}
            itemSize={3}
          />
        </bufferGeometry>
        <lineBasicMaterial attach="material" color="white" transparent opacity={0.25} linewidth={1} />
      </line> */}
      {/* Star 2 - Bottom Left of Triangle */}
      {/* <mesh
        ref={star2}
        geometry={nodes.pCylinder3001.geometry}
        material={materials['blinn2SG.001']}
        position={restPositions[1].toArray()}
        scale={[0.004, 0.004, 0.004]}
        rotation={[0, 0, 0]}
      >
        <meshStandardMaterial 
          color="white"
          metalness={0.5}
          roughness={0.2}
          emissive="white"
          emissiveIntensity={0.5}
        />
      </mesh>
      Trail for Star 2 */}
      {/* <line>
        <bufferGeometry attach="geometry">
          <bufferAttribute
            attach="attributes-position"
            count={trails[1].current.length}
            array={new Float32Array(trails[1].current.flatMap(v => v.toArray()))}
            itemSize={3}
          />
        </bufferGeometry>
        <lineBasicMaterial attach="material" color="white" transparent opacity={0.25} linewidth={1} />
      </line> */}
      {/* Star 3 - Top Right of Triangle */}
      {/* <mesh
        ref={star3}
        geometry={nodes.pCylinder3001.geometry}
        material={materials['blinn2SG.001']}
        position={restPositions[2].toArray()}
        scale={[0.004, 0.004, 0.004]}
        rotation={[0, 0, 0]}
      >
        <meshStandardMaterial 
          color="white"
          metalness={0.5}
          roughness={0.2}
          emissive="white"
          emissiveIntensity={0.5}
        />
      </mesh> */}
      {/* Trail for Star 3 */}
      {/* <line>
        <bufferGeometry attach="geometry">
          <bufferAttribute
            attach="attributes-position"
            count={trails[2].current.length}
            array={new Float32Array(trails[2].current.flatMap(v => v.toArray()))}
            itemSize={3}
          />
        </bufferGeometry>
        <lineBasicMaterial attach="material" color="white" transparent opacity={0.25} linewidth={1} />
      </line> */}
    </group>
  );
}

useGLTF.preload("/models/airplane/Star.glb");